# macros
[gcode_macro Disable_Axis]
gcode:M84

[gcode_macro Z_OffSet]
gcode: probe_calibrate

[respond]

[gcode_macro START_PRINT]
gcode:
    {% set BED_TEMP = params.BED_TEMP|default(60)|float %}
    {% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}
    {% set TEMP_OFFSET = 35 %}
    {% set PREHEAT_TEMP = EXTRUDER_TEMP - TEMP_OFFSET %}

    M140 S{BED_TEMP}     # Start bed heating (but don't wait for it)
    M104 S{PREHEAT_TEMP} # Start preheating extruder below oozing temp
    G90                  # Use absolute coordinates
    G28                  # Home the printer
    M190 S{BED_TEMP}     # Wait for bed to reach temperature
    M109 S{PREHEAT_TEMP} # Wait for extruder to reach preheat temp

    SETUP_KAMP_MESHING DISPLAY_PARAMETERS=1 LED_ENABLE=0 FUZZ_ENABLE=1
    SETUP_LINE_PURGE DISPLAY_PARAMETERS=1 ADAPTIVE_ENABLE=1 PURGE_AMOUNT=40 LINE_LENGTH=50 FLOW_RATE=12 X_DEFAULT=10 Y_DEFAULT=10 DISTANCE_TO_OBJECT_Y=10
    BED_MESH_CLEAR
    BED_MESH_CALIBRATE

    M104 S{EXTRUDER_TEMP} # Set extruder temperature to first layer temp
    M109 S{EXTRUDER_TEMP} # Wait for extruder temperature to reach first layer temp

    LINE_PURGE

    SKEW_PROFILE LOAD=calilantern_skew_profile

[delayed_gcode bed_mesh_init]
initial_duration: .01
gcode:
  BED_MESH_PROFILE LOAD=default

[gcode_macro END_PRINT]
gcode:
    G91 ;Relative positioning
    G1 E-2 F2700 ;Retract a bit
    G1 E-2 Z0.2 F2400 ;Retract and raise Z
    G1 X5 Y5 F3000 ;Wipe out
    G1 Z10 ;Raise Z more
    G90 ;Absolute positioning
    G1 X210 Y210 ;Present print
    M106 S0 ;Turn-off fan
    M104 S0 ;Turn-off hotend
    M140 S0 ;Turn-off bed
    M84 X Y E ;Disable all steppers but Z
    BED_MESH_CLEAR
    SET_SKEW CLEAR=1

[gcode_macro M300]
gcode:
    # Use a default 1kHz tone if S is omitted.
    {% set S = params.S|default(1000)|int %}
    # Use a 10ms duration is P is omitted.
    {% set P = params.P|default(100)|int %}
    SET_PIN PIN=BEEPER_pin VALUE=0.5 CYCLE_TIME={ 1.0/S if S > 0 else 1 }
    G4 P{P}
    SET_PIN PIN=BEEPER_pin VALUE=0

[gcode_macro PID_AUTOTUNE_EXTRUDER_215]
gcode:
    PID_CALIBRATE HEATER=extruder TARGET=215

[gcode_macro PID_AUTOTUNE_BED_65]
gcode:
    PID_CALIBRATE HEATER=heater_bed TARGET=65

# Load Filament Macro
[gcode_macro LOAD]
gcode:
  M104 S215             # set hot end temperature to 215 C
  M109 S215             # wait for hot end temperature to reach 215 C
  M83                   # Put the extruder into relative mode
  G92 E0.0              # Reset the extruder so that it thinks it is at position zero
  G1 E25 F150          # Move the extruder forward 120mm at a speed of 350mm/minute
  G92 E0.0              # Reset the extruder again
  M82                   # Put the extruder back into absolute mode.

#Unload Filament Macro
[gcode_macro UNLOAD]
gcode:
  M104 S215             # set hot end temperature to 210 C
  M109 S215             # wait for hot end temperature to reach 210 C
  M83                   # Put the extruder into relative mode
  G92 E0.0              # Reset the extruder so that it thinks it is at position zero
  G1 E-30 F350         # Move the extruder back 120mm at a speed of 350mm/minute
  G92 E0.0              # Reset the extruder again
  M82                   # Put the extruder back into absolute mode.

# filament change 
[pause_resume]

[gcode_macro M600]
gcode:
    M117 Filament Change
    M118 Filament Change
    SAVE_GCODE_STATE NAME=filament_change
    PAUSE
    LOW_TEMP_CHECK
    G91 # relative
    G1 E-1 F300 # retract 1
    M125 # park
    M702 # unload

    M117 New filament
    M118 New filament
    COUNTDOWN TIME=25 MSG="Switch"
    M701
    COUNTDOWN TIME=10 MSG="Clean"
    RESUME
    M117 Resuming
    M118 Resuming
    RESTORE_GCODE_STATE NAME=filament_change
    M117 Printing..
    M118 Printing..


[gcode_macro SHUTDOWN_MACHINE]
gcode:
  {action_call_remote_method("shutdown_machine")}



[gcode_macro PRESSURE_ADVANCE_SETUP]
gcode:
  SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY=1 ACCEL=500 #This command makes the nozzle travel slower through corners to emphasize the effects of extruder pressure.
  TUNING_TOWER COMMAND=SET_PRESSURE_ADVANCE PARAMETER=ADVANCE START=0 FACTOR=.005 #For printers with a direct drive extruder use factor of 0.005

[gcode_macro BUILD_MESH]
gcode:
    G28 #Home All Axis
    M190 S65 #Wait for bed temperature to hit 60°
    BED_MESH_CALIBRATE #Build mesh
  
  

[gcode_macro PRINTER_POWER_OFF]
gcode:
    {% set data = "off" %}
    {action_call_remote_method("publish_mqtt_topic",
                             topic="power",
                             payload=data,
                             qos=0,
                             retain=False,
                             use_prefix=True)}


[gcode_macro PRINTER_POWER_ON]
gcode:
    {% set data = "on" %}
    {action_call_remote_method("publish_mqtt_topic",
                             topic="power",
                             payload=data,
                             qos=0,
                             retain=False,
                             use_prefix=True)}


[gcode_macro QUICK_PURGE_LINE]
description: prints a purge line on the left edge of the bed
gcode:
  M140 S60              # set bed temperature to 60°C
  M190 S60              # Wait for bed temperature to hit 60°C
  M104 S210             # set hot end temperature to 210°C
  M109 S210             # wait for hot end temperature to reach 210°C
  START_PRINT
  END_PRINT


[gcode_macro EXTRUDE_100]
description: Extrudes 100mm of filament to measure for e-step calibration
gcode:
  M104 S210             # set hot end temperature to 210°C
  M109 S210             # wait for hot end temperature to reach 210°C
  G28                   #Home all axis
  G1 Z50 F250           #Moves Z 50mm to give space for filament to extrude
  M83                   #set relative mode
  G1 F60                #set feedrate to 60mm/min
  G1 E100               #extrude 100mm of filament


[gcode_macro LOAD_FILAMENT]
gcode:
    {% set speed = params.SPEED|default(300) %}
    {% set max_velocity = printer.configfile.settings['extruder'].max_extrude_only_velocity %}
    SAVE_GCODE_STATE NAME=load_state
    M300 # beep
    G91
    G92 E0
    G1 E35 F{max_velocity} # fast-load
    G1 E25 F{speed} # purge
    M300
    M300
    RESTORE_GCODE_STATE NAME=load_state


[gcode_macro UNLOAD_FILAMENT]
gcode:
    {% set speed = params.SPEED|default(300) %}
    {% set max_velocity = printer.configfile.settings['extruder'].max_extrude_only_velocity %}
    SAVE_GCODE_STATE NAME=unload_state
    G91
    M300 # beep
    G92 E0
    G1 E25 F{speed} # purge
    G1 E-30 F{max_velocity} # fast-unload
    M300
    M300
    RESTORE_GCODE_STATE NAME=unload_state

#
# Pressure Advance calibration test.
#
# The main reason for this test is that the standard tuning tower provides ambigious, open to interpretation readings with a broad margin for error.
# This test provides control values next to the values being tested, so differences are easier to notice at a glance.
#
# Prints a series of bands, 6 lines per each, with the first 3 lines printed slowly and used as baseline/control and the other 3
# at two different speeds in the following sequence: 25% at 40mm/sec, 50% at 120mm/sec, 25% at 40mm/sec.
# Pressure Advance value is being increased for every band starting from 0.01 with 0.002 increments.
#
# The printed model should be inspected by looking at the top and bottom lines in each band, on the right side of the two vertical raft bars (where the print speeds change).
# Find the highest band from the bottom where the lines at its top still resemble the lines at its bottom, with no visible extrusion width irregularities.
# Then the pressure advance value is calculated as follows:
#    PA = START + (INCREMENT * band_number)
# Which in case of using default values, would be:
#    PA = 0.01 + (0.002 * band_number)
#
# You might also want to repeat the test using a START value that is slightly less that your calculated PA value, and smaller INCREMENTs
# to narrow down and refine your PA value further.
#
# This macro is parametric and most of the values can be adjusted with their respective input parameters.
# It can be called without any input parameters - in which case the default values would be used - or with any combination of parameters as desired. 
#
# Make sure your axis are homed, your bed mesh is loaded (if you are using one) and both the hotend and the bed are at the temperature required for your filament.
# Usage:
#   PRESSURE_ADVANCE_CALIBRATION START=0.01 INCREMENT=0.002 RAFT=1
#
# Primary input parameters:
#    START       : default(0.02)   PA value to start with
#    INCREMENT   : default(0.005)  PA value to increment for each subsequent band
#    DO_RAFT     : default(1)      whether to print a raft or not. printing one makes the finished test east to remove from the bed
#    EXTRUSION_MULTIPLIER: default(1.25 if raft enabled, 1.5 if disabled)   extrusion multiplier to apply to printing lines in the band
#
# Other tunable parameters:
#    PRINT_SIZE    : default(120)    maximum width/height, in mm,  that the test can make use of. the model will be printed in the middle of the bed
#    BANDS_LIMIT   : default(999)    optionally the number of bands can be limited this way. otherwise as many bands that fit in the given SIZE will be printed
#    CONTROL_SPEED : default(30)     speed at which the control lines in a band are printed at, mm/sec
#    OUTER_SPEED   : default(40)     speed of printing the outer parts of the test lines in a band, mm/sec
#    INNER_SPEED   : default(80)     speed of printing the middle part of the test lines in a band, mm/sec
#    TRAVEL_SPEED  : default(200)    speed of travel moves, mm/sec
#    RAFT_SPEED    : default(80)     speed of printing the raft, if enabled, mm/sec
#    LINES_PER_BAND: default(6)    number of lines per band. half of these will be control, another half the test lines
#    RETRACT_LENGTH: default(0.6)  retraction, in mm, to perform when traveling   
#    PURGE_MM      : default(8)    purge this amount of mm of filament before starting the print
#    LINE_SPACING  : default(0.4)  spacing between individual lines in a band
#
# Play wround with enabling or disabling rafts, changing extrusion multiplier to get thicker lines where Pa changes would be easier to notice, or using
# OUTER and INNER speeds that are more realistic and closer to actual printing conditions: such as the speeds used for external and internal perimeters,
# or internal perimeters and infill. The default values for SLOW and FAST speeds are taken from Stephan's PIF profile for external and internal perimeters.
#
# @version: 1.2
# 
# Based on the idea from a post by DonStauffer on https://forum.duet3d.com/topic/25161/my-pressure-advance-calibration
#
[gcode_macro PRESSURE_ADVANCE_CALIBRATION]
description: Calibrate the pressure advance by printing a grid pattern
gcode:
    # 
    # input and tunables
    #
    {% set pa_start     = params.START|default(0.02)|float %}       # starting PA value
    {% set pa_increment = params.INCREMENT|default(0.005)|float %}  # how much to increment PA per band

    {% set do_raft = params.DO_RAFT|default(1)|int %}  # whether to print a raft or not
    
    {% set print_size      = params.PRINT_SIZE|default(120)|int %}                # width/height of the printed test
    {% set num_bands       = params.BANDS_LIMIT|default(999)|int %}               # limit the number of bands to print. othwerwise print as many as would fit within a given size
    {% set lines_per_band  = params.LINES_PER_BAND|default(6)|int %}              # number of lines per band. half are control, another half the test
    {% set e_multiplier    = params.EXTRUSION_MULTIPLIER|default(1.25 if do_raft == 1 else 1.5)|float %},  # extrusion multiplier for line print moves
    {% set retract_length  = params.RETRACT_LENGTH|default(0.6)|float %}          # how much to retract when traveling between print moves
    {% set initial_purge   = params.PURGE_MM|default(8)|int %}                    # mm of filament to purge before printing. set to 0 to disable

    {% set feedrate_control = params.CONTROL_SPEED|default(30)|int * 60 %}  # print feedrate of the line in the middle of the band
    {% set feedrate_outer   = params.OUTER_SPEED|default(40)|int * 60 %}    # print feedrate of the lines on the sides of the band
    {% set feedrate_inner   = params.INNER_SPEED|default(120)|int * 60 %}   # print feedrate of the line in the middle of the band
    {% set feedrate_travel  = params.TRAVEL_SPEED|default(200)|int * 60 %}  # travel feedrate between print moves
    {% set feedrate_raft    = params.RAFT_SPEED|default(120)|int * 60 %}    # print feedrate for printing raft
    {% set feedrate_z       = 5 * 60 %}   # z axis travel feedrate
    {% set feedrate_retract = 50 * 60 %}  # retract and deretract feedrate
    
    {% set spacing_line  = params.LINE_SPACING|default(0.4)|float %}  # distance between lines in a band
    {% set spacing_band  = 2 %}                                       # distance between individual bands
    {% set spacing_raft  = 2 %}                                       # distance between raft lines
    
    {% set fast_line_ratio_percent = 50 %}
    # sanity check
    {% set lines_per_band    = [2, lines_per_band]|max %}
    {% set e_multiplier      = [1, e_multiplier]|max %}
    {% set num_lines_control = (lines_per_band / 2)|round(0, 'floor')|int %}
    {% set num_lines_test    = (lines_per_band / 2)|round(0, 'ceil')|int %}
    {% set spacing_line      = spacing_line * (1 + e_multiplier - 1.25) %}  # the higher the extrusion multiplier the wider the spacing
    # computed values
    {% set max_x = printer.toolhead.axis_maximum.x|float %}
    {% set max_y = printer.toolhead.axis_maximum.y|float %}
    {% set nozzle_diameter = printer.configfile.config['extruder'].nozzle_diameter|float %}
    {% set line_width    = nozzle_diameter * 1.25 %}
    {% set line_height   = nozzle_diameter / 2 %}
    {% set z_hop_height  = 2 * line_height %}
    {% set e_per_mm      = (line_width * line_height) / (3.1415 * (1.75/2)**2) %} 
    {% set spacing_purge = line_height * 0.8 %}  # distance between purge lines and raft
    # set print width to align with the raft grid
    {% set spacing_raft   = (spacing_raft / line_width)|round * line_width %}  # align raft spacing to multiples of line width
    {% set num_raft_lines = ([print_size, max_x]|min / spacing_raft)|round(0, 'floor')|int %}
    {% set print_width    = num_raft_lines * spacing_raft %}
    # adjust print height to align with the band grid
    {% set band_height      = lines_per_band * line_width + (lines_per_band - 1) * spacing_line + spacing_band %}
    {% set bands_per_height = (([print_size, max_y]|min  - spacing_purge) / band_height)|round(0, 'floor')|int %}
    {% set num_bands        = [num_bands, bands_per_height]|min %}  
    {% set print_height     = num_bands * band_height - spacing_band - spacing_purge %}
    # adjust slow and fast line lengths to align with raft grid
    {% set slow_line_length = ((print_width * (1 - fast_line_ratio_percent / 100) / 2) / spacing_raft)|round * spacing_raft + spacing_raft / 2 %}  # ends between raft lines
    {% set fast_line_length = print_width - slow_line_length * 2 %}
    {% set thick_raft_num1 = (slow_line_length / spacing_raft)|round|int %}
    {% set thick_raft_num2  = num_raft_lines - thick_raft_num1 + 1 %}
    # find start position
    {% set x_start = max_x / 2 - print_width  / 2 %}
    {% set y_start = max_y / 2 - print_height / 2 %}

    {action_respond_info("")}
    {action_respond_info("Starting Pressure Advance calibration print.")}
    {action_respond_info("")}
    {action_respond_info("This operation can not be interrupted by normal means. Hit the \"emergency stop\" button once the print starts exhibiting PA values that are obviously too high.")}
    {action_respond_info("")}
    {action_respond_info("PA of first band: %.4f" % pa_start)}
    {action_respond_info("PA of last band: %.4f" % (num_bands * pa_increment))}
    {action_respond_info("PA increment per band: %.4f" % pa_increment)}
    {action_respond_info("Number of bands: %d" % num_bands)}
    {action_respond_info("")}
    {action_respond_info("Inspect the printed model. "
      "Look at the top and bottom lines in each band, on the right side of the two vertical raft bars (where the print speeds change). "
      "Find the highest band from the bottom where the lines at its top still resemble the lines at its bottom, with no visible extrusion width irregularities. "
      "Your final Pressure Advance value would then be:"
    )}
    {action_respond_info("")}
    {action_respond_info("Assuming that first band_number is 0")}
    {action_respond_info("PA = %.4f + (%.4f * band_number)" % (pa_start, pa_increment))}
    {action_respond_info("")}
    {action_respond_info("Update your [extruder] config section and set \"pressure_advance\" to the value you calculated.")}
    {action_respond_info("")}

    # The printed model should be inspected by 
# 
# Then the pressure advance value is calculated as follows:
#    PA = START + (INCREMENT * band_number)
# Which in case of using default values, would be:
#    PA = 0.01 + (0.002 * band_number)
#
   
    SAVE_GCODE_STATE NAME=STATE_PRESSURE_ADVANCE_CALIBRATION
    {% set pa_saved = printer.configfile.settings['extruder'].pressure_advance %}
    SET_PRESSURE_ADVANCE ADVANCE={pa_start}  # start with a given PA
    
    #
    # set extrude_factor to 1 
    #
    M221 S100

    #
    # purging before raft
    #
    M117 Priming
    G90  # absolute coords
    G0 X{x_start} Y{y_start} Z{line_height} F{feedrate_travel}  # move to start position
    G91  # relative positioning
    G1 E{initial_purge} F{5 * 60}  # extrude at ~12mm3/sec
    G1 X{print_width}  E{print_width * e_per_mm} F{feedrate_raft / 2}  # print prime line
    G1 Y{line_width}   E{line_width * e_per_mm}  F{feedrate_raft / 2}  # move to next line
    G1 X-{print_width} E{print_width * e_per_mm} F{feedrate_raft / 2}  # print prime line
    
    #
    # print the raft
    #
    {% if do_raft == 1 %}
      G0 F{feedrate_raft} # set print speed
      
      {% for curr_raft_line in range(1, num_raft_lines + 2) %} # rafts need to be on both sides
          # see if we need to print thick raft on slow/fast line boundary
          {% if curr_raft_line == thick_raft_num1 or curr_raft_line == thick_raft_num2 %}
              G1 Y{loop.cycle(1.0, -1.0) * print_height} E{print_height * e_per_mm}
              G1 X{line_width} E{line_width * e_per_mm}  
              G1 Y{loop.cycle(-1.0, 1.0) * print_height} E{print_height * e_per_mm}
              G1 X{line_width} E{line_width * e_per_mm}  
          {% endif %}
          
          G1 Y{loop.cycle(1.0, -1.0) * print_height} E{print_height * e_per_mm} # print the vertical raft line

          # move over to next column
          {% if not loop.last %}
            {% set horizontal_move = spacing_raft - (2 * line_width if curr_raft_line == thick_raft_num1 - 1 or curr_raft_line == thick_raft_num2 - 1 else 0) %}
            G1 X{horizontal_move} E{horizontal_move * e_per_mm}  
          {% endif %}
      {% endfor %}

      G1 E-{retract_length} F{feedrate_retract}  # retract
      G0 Z{z_hop_height} F{feedrate_z}           # z-hop
    {% endif %}

    #
    # print the bands
    #
    M117 Printing bands
    G90  # absolute coords
    G0 X{x_start} Y{y_start + 2 * line_width + spacing_purge} F{feedrate_travel}  # move to XY start position
    G0 Z{line_height + (line_height if do_raft == 1 else 0)} F{feedrate_z}        # move to Z start position
    G91  # relative positioning
    G1 E{retract_length} F{feedrate_retract}  # unretract

    # print bands
    {% for curr_band_num in range(0, num_bands ) %}
      {% set outer_loop = loop %}

      {% set curr_pa_value = pa_start + curr_band_num * pa_increment %}
      SET_PRESSURE_ADVANCE ADVANCE={curr_pa_value}  # set PA
      M117 Band {curr_band_num} PA {curr_pa_value|round(4)}

      # print control lines
      {% for _ in range(num_lines_control) %}
        G1 X{print_width} E{print_width * e_per_mm * e_multiplier} F{feedrate_control} # print line

        G1 E-{retract_length} F{feedrate_retract}  # retract
        G0 Z{z_hop_height} F{feedrate_z}           # z-hop

        G0 X-{print_width} Y{spacing_line + line_width} F{feedrate_travel}  # move to start of next line

        G0 Z-{z_hop_height} F{feedrate_z}         # unz-hop
        G1 E{retract_length} F{feedrate_retract}  # unretract
      {% endfor %}

      # print test lines
      {% for _ in range(num_lines_test) %}
        {% for data in [{'mm': slow_line_length, 'f': feedrate_outer}, {'mm': fast_line_length, 'f': feedrate_inner}, {'mm': slow_line_length, 'f': feedrate_outer}] %}
          G1 X{data.mm} E{data.mm * e_per_mm * e_multiplier} F{data.f} # print line
        {% endfor %}

        G1 E-{retract_length} F{feedrate_retract}  # retract
        G0 Z{z_hop_height} F{feedrate_z}           # z-hop

        {% if not (outer_loop.last and loop.last) %}
          G0 X-{print_width} Y{(spacing_line if not loop.last else spacing_band) + line_width} F{feedrate_travel}  # move to start of next line
          G0 Z-{z_hop_height} F{feedrate_z}         # unz-hop
          G1 E{retract_length} F{feedrate_retract}  # unretract
        {% endif %}
      {% endfor %}
    {% endfor %}

    #
    # retract and move away
    #
    G1 E-{retract_length} F{feedrate_retract}  # retract
    G0 Z20 F{feedrate_z}  # up
    G0 X-{print_width / 2} Y{[50, max_y - (y_start + print_height)]|min} F{feedrate_travel}  # center back
    
    M117  # clear the LCD
    SET_PRESSURE_ADVANCE ADVANCE={pa_saved}  # restore original PA
    RESTORE_GCODE_STATE NAME=STATE_PRESSURE_ADVANCE_CALIBRATION

#####################################################################
#  Filament change macro M600
#####################################################################

[gcode_macro M600]
variable_park_x: 10 # try half your bed size.
variable_park_y: 10
variable_z_lift: 50
variable_velocity: 60
variable_retract: 0.5
gcode:
    SAVE_GCODE_STATE NAME=STATE_M600    # remembers the position
    
    PAUSE_BASE    
    # Fluidd redifines PAUSE to move the the back corner of the printer.  We don't want that.  This is what Fluidd renamed basic pause to. 
    # Mainsail renames PAUSE to "BASE_PAUSE", so you should probably use that instead.  If using other software, probably just use PAUSE.   
    
    # safe park coords
    {% set th = printer.toolhead %}
    {% set park_x = [params.X|default(park_x)|int, th.axis_maximum.x-2]|min %}
    {% set park_y = [params.Y|default(park_y)|int, th.axis_maximum.y-10]|min %}
    {% set park_z = [th.position.z + params.Z_LIFT|default(z_lift)|int, th.axis_maximum.z]|min %}
    {% set park_feedrate = params.VELOCITY|default(velocity)|int * 60 %}
    
    # retract at 50mm/sec
    G91
    G1 E-{retract} F3000
    
    # park toolhead
    G90
    G0 X{park_x} Y{park_y} Z{park_z} F{park_feedrate}
    
    # Tell user to reload filament
    M117 Reload Filament
    
    RESTORE_GCODE_STATE NAME=STATE_M600
# End of gcode script

[gcode_macro _TIMELAPSE_NEW_FRAME]
gcode:
 {action_call_remote_method("timelapse_newframe")}
 ; leave this in a separate macro!

[gcode_macro TIMELAPSE_TAKE_FRAME]
gcode:
  G10
  SAVE_GCODE_STATE NAME=SNAPSHOT
  G1 X175.0 F10000
  G1 Y100.0 F10000
  G4 P500 ;dwell
  M400    ;clear buffer
  _TIMELAPSE_NEW_FRAME
  G4 P250 ;moar dwelling
  M400
  RESTORE_GCODE_STATE NAME=SNAPSHOT MOVE=1
  G11
  

[gcode_macro TIMELAPSE_RENDER]
gcode:
  {action_call_remote_method("timelapse_render")}

[gcode_macro TOGGLE_LEDLIGHTS]
gcode:
  SET_PIN PIN=LEDlights VALUE={(not printer['output_pin LEDlights'].value)|int}

# Copyright (C) 2023 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.
#
# Credit to original inspiration:
# https://gist.github.com/ChipCE/95fdbd3c2f3a064397f9610f915f7d02
# Copyright (C) 2023 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.
#
# Credit to original inspiration:
# https://gist.github.com/ChipCE/95fdbd3c2f3a064397f9610f915f7d02

[gcode_macro bed_mesh_calibrate_fast]
description: Wraps BED_MESH_CALIBRATE, scaling probe count to specified area.
  Usage: See Klipper documentation.
gcode:
  # Abort on a bad config.
  BED_MESH_CHECK ABORT=1

  # Find the real bed_mesh_calibrate command.
  {% set calibrate_cmd =
           (printer["gcode_macro list_macros"].macros.bed_mesh_calibrate|
              default(["bed_mesh_calibrate"],True))[-1] %}

  {% set km = printer["gcode_macro _km_globals"] %}
  {% set probe_mesh_padding = km.probe_mesh_padding %}
  {% set probe_min_count = km.probe_min_count %}
  {% set probe_count_scale = km.probe_count_scale %}
  {% set bed_mesh = printer.configfile.settings.bed_mesh %}

  # TODO: Handle the math for a delta bed.
  {%if "mesh_radius" not in bed_mesh and
       "MESH_RADIUS" not in params %}
    {% set safe_min_x = bed_mesh.mesh_min[0] %}
    {% set safe_min_y = bed_mesh.mesh_min[1] %}
    {% set safe_max_x = bed_mesh.mesh_max[0] %}
    {% set safe_max_y = bed_mesh.mesh_max[1] %}

    # Always bound MESH_MIN and MESH_MAX.
    {% if "MESH_MIN" in params %}
      {% set mesh_min_x = (params.MESH_MIN.split(",")[0]|float -
                           probe_mesh_padding, safe_min_x)|max %}
      {% set mesh_min_y = (params.MESH_MIN.split(",")[1]|float -
                           probe_mesh_padding, safe_min_y)|max %}
    {% else %}
      {% set mesh_min_x = safe_min_x %}
      {% set mesh_min_y = safe_min_y %}
    {% endif %}
    {% if "MESH_MAX" in params %}
      {% set mesh_max_x = (params.MESH_MAX.split(",")[0]|float +
                           probe_mesh_padding, safe_max_x)|min %}
      {% set mesh_max_y = (params.MESH_MAX.split(",")[1]|float +
                           probe_mesh_padding, safe_max_y)|min %}
    {% else %}
      {% set mesh_max_x = safe_max_x %}
      {% set mesh_max_y = safe_max_y %}
    {% endif %}

    {% set probe_count = bed_mesh.probe_count if not params.PROBE_COUNT else
                         params.PROBE_COUNT.split(",")|map('int')|list %}
    # Don't scale the probe count if one was explicitly provided.
    {% if "PROBE_COUNT" not in params %}
      {% set max_x_probes = probe_count[0] %}
      {% set max_y_probes = probe_count[-1] %}

      {% set x_probes = (max_x_probes * (mesh_max_x - mesh_min_x) /
                         (safe_max_x - safe_min_x) * probe_count_scale)
                        | round(0) | int %}
      {% set x_probes = ((x_probes, probe_min_count)|max, max_x_probes)|min %}

      {% set y_probes = (max_y_probes * (mesh_max_y - mesh_min_y ) /
                         (safe_max_y - safe_min_y) * probe_count_scale )
                        | round(0) | int %}
      {% set y_probes = ((y_probes, probe_min_count)|max, max_y_probes)|min %}
      # Add probes for bicubic if one axis has too many probes for lagrange.
      {% if x_probes > 6 and y_probes < 4 %}
        {% set y_probes = 4 %}
      {% elif y_probes > 6 and x_probes < 4 %}
        {% set x_probes = 4 %}
      {% endif %}
      {% set probe_count = [x_probes,y_probes] %}
    {% elif probe_count|length == 1 %}
      {% set dummy = probe_count.append(probe_count[0]) %}
    {% endif %}

    # If the config includes a relative_reference_index then we need to find the
    # point in the new mesh that's closest to the index point in the mesh that
    # the config would have generated.
    # TODO: Could also adjust the mesh parameters in here to ensure it includes
    # the original index point, but that would be extra work and would cause
    # slower probes if the mesh needs to be expanded to include the point.
    {% if "relative_reference_index" in bed_mesh %}
      {% set row = (bed_mesh.relative_reference_index / bed_mesh.probe_count[0]
                    )|int%}
      {% set rrf_x = (((safe_max_x - safe_min_x) /
                       (bed_mesh.probe_count[0] - 1))|round(2, 'floor')) *
                     (bed_mesh.relative_reference_index %
                      bed_mesh.probe_count[-1]) %}
      {% if row % 2 %}
        {% set rrf_x = safe_max_x - rrf_x %}
      {% else %}
        {% set rrf_x = safe_min_x + rrf_x %}
      {% endif %}
      {% set rrf_y = (((safe_max_y - safe_min_y) /
                       (bed_mesh.probe_count[-1] - 1))|round(2, 'floor')) *
                     row + safe_min_x %}
      {% set x_dist = (mesh_max_x - mesh_min_x) / (probe_count[0] - 1) %}
      {% set y_dist = (mesh_max_y - mesh_min_y) / (probe_count[1] - 1) %}
      {% set rrf = {'x':0, 'y':0, 'dist':safe_max_x**2+safe_max_y**2,'pos':0} %}
      {% for row in range(probe_count[1])%}
        {% for col in range(probe_count[0])%}
          {% if row % 2 %}
            {% set x = mesh_max_x - col * x_dist %}
          {% else %}
            {% set x = mesh_min_x + col * x_dist %}
          {% endif %}
          {% set y = mesh_min_y + row * y_dist %}
          {% set dist = ((x - rrf_x)**2 + (y - rrf_y)**2)**0.5 %}
          {% if dist < rrf.dist %}
            {% set dummy = rrf.__setitem__("dist", dist) %}
            {% set dummy = rrf.__setitem__("x", x) %}
            {% set dummy = rrf.__setitem__("y", y) %}
            {% set dummy = rrf.__setitem__("pos", row * probe_count[1] + col) %}
          {% endif %}
        {% endfor %}
      {% endfor %}
      {% if rrf.x != rrf_x or rrf.y != rrf_y %}
        {action_respond_info("relative_reference_index remapped to"
                             " %d (%.2f,%.2f) from %d (%.2f,%.2f)" %
                             (rrf.pos, rrf.x, rrf.y,
                              bed_mesh.relative_reference_index, rrf_x, rrf_y))}
      {% endif %}
      {% set dummy = params.__setitem__("RELATIVE_REFERENCE_INDEX", rrf.pos) %}
    {% endif %}

    {% set dummy = params.__setitem__("MESH_MIN", mesh_min_x~","~mesh_min_y) %}
    {% set dummy = params.__setitem__("MESH_MAX", mesh_max_x~","~mesh_max_y) %}
    {% set dummy = params.__setitem__("PROBE_COUNT", probe_count|join(',')) %}
    # Force bicubic if we've exceeded the max for lagrange.
    {% if probe_count[0] > 6 or probe_count[1]|default(0) > 6 %}
      {% set dummy = params.__setitem__("ALGORITHM", "bicubic") %}
    {% endif %}
    # Warn on bad parameters that were fixed.
    {% if "MESH_MIN" in params or "MESH_MAX" in params %}
      BED_MESH_CHECK {rawparams}
    {% endif %}
  {% else %}
    # Mesh limits may be out of bounds, so strip them from the fallback path.
    {% set dummy = params.__delitem__("MESH_MIN") %}
    {% set dummy = params.__delitem__("MESH_MAX") %}
  {% endif %}
  # Abort on bad parameters.
  {% if "MESH_MIN" in params or "MESH_MAX" in params %}
    BED_MESH_CHECK ABORT=1{%for k in params%}{' '~k~'="'~params[k]~'"'}{%
                            endfor%}
  {% endif %}
  _KM_PRINT_STATUS ACTION=PUSH_STATUS
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=meshing
  {calibrate_cmd}{%for k in params%}{' '~k~'="'~params[k]~'"'}{%endfor%}
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=pop_status

[gcode_macro bed_mesh_check]
description: Warns if bed_mesh config may generate an invalid mesh.
  Usage: BED_MESH_CHECK [MESH_MIN=<x,y>] [MESH_MAX=<x,y>] [ABORT=<0|1>]
gcode:
  {% if printer.bed_mesh is defined %}
    {% set action = action_respond_info if params.ABORT|default(0)|int == 0 else
                    action_raise_error %}
    {% set settings = printer.configfile.settings %}
    {% set x_min = settings.stepper_x.position_min %}
    {% set y_min = settings.stepper_y.position_min %}
    {% set x_max = settings.stepper_x.position_max %}
    {% set y_max = settings.stepper_y.position_max %}

    {% set label = "[bed_mesh] config" %}
    {% if "MESH_MIN" in params %}
      {% set label = "BED_MESH_CALIBRATE params" %}
      {% set mesh_min_x = params.MESH_MIN.split(",")[0]|float %}
      {% set mesh_min_y = params.MESH_MIN.split(",")[1]|float %}
    {% else %}
      {% set mesh_min_x = settings.bed_mesh.mesh_min[0] %}
      {% set mesh_min_y = settings.bed_mesh.mesh_min[1] %}
    {% endif %}
    {% if "MESH_MAX" in params %}
      {% set label = "BED_MESH_CALIBRATE params" %}
      {% set mesh_max_x = params.MESH_MAX.split(",")[0]|float %}
      {% set mesh_max_y = params.MESH_MAX.split(",")[1]|float %}
    {% else %}
      {% set mesh_max_x = settings.bed_mesh.mesh_max[0] %}
      {% set mesh_max_y = settings.bed_mesh.mesh_max[1] %}
    {% endif %}

    {% if "bltouch" in settings %}
        {% set x_offset = settings.bltouch.x_offset %}
        {% set y_offset = settings.bltouch.y_offset %}
        {% set probe = "bltouch" %}
    {% elif "probe" in settings %}
        {% set x_offset = settings.probe.x_offset %}
        {% set y_offset = settings.probe.y_offset %}
        {% set probe = "probe" %}
    {% else %}
        {% set x_offset = 0.0 %}
        {% set y_offset = 0.0 %}
    {% endif %}

    {% set output = [] %}
    {% set warn =
         "* mesh_%s (%f, %f) adjusted by " ~ probe ~
         ".%s_offset (%f) can move out of range for "
         "stepper_%s.position_%s (%f)." %}
    {% if x_offset > 0 and (mesh_min_x - x_offset) < x_min %}
      {% set dummy = output.append(warn % ('min', mesh_min_x, mesh_min_y,
                                           'x', x_offset, 'x', 'min', x_min)) %}
    {% elif x_offset < 0 and (mesh_max_x - x_offset) > x_max %}
      {% set dummy = output.append(warn % ('max', mesh_max_x, mesh_max_y,
                                           'x', x_offset, 'x', 'max', x_max)) %}
    {% endif %}
    {% if y_offset > 0 and (mesh_min_y - y_offset) < y_min %}
      {% set dummy = output.append(warn % ('min', mesh_min_x, mesh_min_y,
                                           'y', y_offset, 'y', 'min', y_min)) %}
    {% elif y_offset < 0 and (mesh_max_y - y_offset) > y_max %}
      {% set dummy = output.append(warn % ('max', mesh_max_x, mesh_max_y,
                                           'y', y_offset, 'y', 'max', y_max)) %}
    {% endif %}

    {% if output %}
      { action(
        "Warning: The following issue(s) were detected in your " ~ label ~
        ":\n" ~ output|join("\n")) }
    {% endif %}
  {% endif %}

[gcode_macro _CLIENT_VARIABLE]
variable_use_custom_pos   : True ; use custom park coordinates for x,y [True/False]
variable_custom_park_x    : 0.0   ; custom x position; value must be within your defined min and max of X
variable_custom_park_y    : 0.0   ; custom y position; value must be within your defined min and max of Y
variable_custom_park_dz   : 2.0   ; custom dz value; the value in mm to lift the nozzle when move to park position
variable_retract          : 1.0   ; the value to retract while PAUSE
variable_cancel_retract   : 5.0   ; the value to retract while CANCEL_PRINT
variable_speed_retract    : 35.0  ; retract speed in mm/s
variable_unretract        : 1.0   ; the value to unretract while RESUME
variable_speed_unretract  : 35.0  ; unretract speed in mm/s
variable_speed_hop        : 15.0  ; z move speed in mm/s
variable_speed_move       : 100.0 ; move speed in mm/s
variable_park_at_cancel   : True ; allow to move the toolhead to park while execute CANCEL_PRINT [True/False]
variable_park_at_cancel_x : 0.0  ; different park position during CANCEL_PRINT [None/Position as Float]; park_at_cancel must be True
variable_park_at_cancel_y : 237.0  ; different park position during CANCEL_PRINT [None/Position as Float]; park_at_cancel must be True
gcode:

# Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro _check_fan_params]
gcode:
  {% set MAXIMUM = params.MAXIMUM|default(
      printer["gcode_macro set_fan_scaling"].maximum)|int %}
  {% set MINIMUM = params.MINIMUM|default(
      printer["gcode_macro set_fan_scaling"].minimum)|int %}

  {% if params.SCALE and params.SCALE|float <= 0 %}
    { action_raise_error("SCALE must be a positive value.") }
  {% elif MINIMUM < 0 or MINIMUM > 255 %}
    { action_raise_error("MINIMUM must be between 0 and 255.") }
  {% elif MAXIMUM < 0 or MAXIMUM > 255 %}
    { action_raise_error("MAXIMUM must be between 0 and 255.") }
  {% elif params.SPEED and (params.SPEED|int < 0 or params.SPEED|int > 255) %}
    { action_raise_error("SPEED must be between 0 and 255.") }
  {% elif params.BOOST and (params.BOOST|int < 0 or params.BOOST|int > 255) %}
    { action_raise_error("BOOST must be between 0 and 255.") }
  {% elif MINIMUM > MAXIMUM %}
    { action_raise_error("MINIMUM must be less than or equal to MAXIMUM.") }
  {% endif %}

# Sets optional scaling factor, minimum, and maximum applied to M106 commmand.
# If a MINIMUM greater than 0 is specified the fan will not stop unless an
# M107 command is issued. SET_FAN_SCALING always displays the current paramaters
# if scaling is active. SET_FAN_SCALING without any arguments will display the
# current scaling parameters without changing them.
[gcode_macro set_fan_scaling]
description: Sets fan scaling factors applied to M106 command. If a speed is
  provided it will be adjusted according to the scaling parameters.
  Usage: SET_FAN_SCALING [SCALE=<scale>] [BOOST=<boost>] [MAXIMUM=<max>]
                         [MINIMUM=<min>] [SPEED=<speed>]
variable_scale: 1.0
variable_boost: 0
variable_minimum: 0
variable_maximum: 255
variable_real_speed: 0
gcode:
  _CHECK_FAN_PARAMS{% for k in params %}{' '~k~'='~params[k]}{% endfor %}
  {% set SCALE = params.SCALE|default(scale)|float %}
  {% set BOOST = params.BOOST|default(boost)|float %}
  {% set MAXIMUM = params.MAXIMUM|default(maximum)|int %}
  {% set MINIMUM = params.MINIMUM|default(minimum)|int %}
  {% set SPEED = params.SPEED|default(real_speed)|int %}

  {% if SCALE != 1.0 or BOOST != 0 or MAXIMUM != 255 or MINIMUM != 0 %}
    {action_respond_info("Fan: Scale: %.2f Minimum:%i Maximum: %i Speed: %i"|
                         format(SCALE, MINIMUM, MAXIMUM, SPEED))}
  {% endif %}

  # Update parameters on change.
  {% if params|length > 0 %}
    SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=scale VALUE="{SCALE}"
    SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=boost VALUE="{BOOST}"
    SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=minimum VALUE="{MINIMUM}"
    SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=maximum VALUE="{MAXIMUM}"
    # Run fan at adusted speed
    M106 S{SPEED}
  {% endif %}
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.SCALE|default(1.0)|float %}
  {% set dummy = params.BUMP|default(0)|int %}
  {% set dummy = params.MAXIMUM|default(255)|int %}
  {% set dummy = params.MINIMUM|default(0)|int %}
  {% set dummy = params.SPEED|default(current speed)|int %}
  " %} # End argument block for Mainsail

[gcode_macro reset_fan_scaling]
description: Clears all fan scaling factors.
  Usage: RESET_FAN_SCALING
gcode:
  SET_FAN_SCALING SCALE=1.0 BOOST=0 MAXIMUM=255 MINIMUM=0

[gcode_macro m106]
description: Wraps M106 to implement scaling overrides.
rename_existing: M106.6245197
gcode:
  {% set S = params.S|default(255)|int %}
  {% if S > 255 or S < 0 %}
    { action_raise_error("S[%i] out of range.") | format(S) }
  {% endif %}

  {% set scale = printer["gcode_macro set_fan_scaling"] %}
  SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=real_speed VALUE="{S}"
  M106.6245197 S{((((S + scale.boost) * scale.scale) | round | int,
                   scale.minimum) | max, scale.maximum) | min}

[gcode_macro M300]
gcode:
    # Use a default 1kHz tone if S is omitted.
    {% set S = params.S|default(1000)|int %}
    # Use a 10ms duration is P is omitted.
    {% set P = params.P|default(100)|int %}
    SET_PIN PIN=BEEPER_pin VALUE=0.5 CYCLE_TIME={ 1.0/S if S > 0 else 1 }
    G4 P{P}
    SET_PIN PIN=BEEPER_pin VALUE=0

#####################################################################

[gcode_macro RESONANCES_TEST]
description: Run input shaper test
gcode:
  {% set user = printer['gcode_macro _USER_VARIABLE'] %}
  _CG28                                                 ; home if needed
  TURN_OFF_HEATERS                                      ; turn off heaters
  M107                                                  ; turn off fan
  {% if user.hw.chamber.fan %} M141 {% endif %}         ; exhaust fan off
  {% if user.hw.filter.ena %} _SET_FILTER {% endif %}   ; filter off
  _PRINT_AR T="INPUT SHAPER: Noise values, check if sensor is installed"
  MEASURE_AXES_NOISE                                    ; get noise value in log
  _PRINT_AR T="INPUT SHAPER: Resonance Tests starting"
  _PRINT_AR T="INPUT SHAPER: Mesasure X axis"
  TEST_RESONANCES AXIS=X                                ; measure X
  _PRINT_AR T="INPUT SHAPER: Mesasure Y axis"
  TEST_RESONANCES AXIS=Y                                ; measure Y
  _PRINT_AR T="INPUT SHAPER: Resonance Tests done"
  _PRINT_AR T="INPUT SHAPER: Generate graph in backround"
  RUN_SHELL_COMMAND CMD=plot_graph PARAMS=SHAPER

[gcode_macro BELT_TEST]
description: Run resonance test to analyze belts
gcode:
  {% set user = printer['gcode_macro _USER_VARIABLE'] %}
  _CG28                                                 ; home if needed
  TURN_OFF_HEATERS                                      ; turn off heaters
  M107                                                  ; turn off fan
  {% if user.hw.chamber.fan %} M141 {% endif %}         ; exhaust fan off
  {% if user.hw.filter.ena %} _SET_FILTER {% endif %}   ; filter off
  _PRINT_AR T="BELT TEST: Noise values, check if sensor is installed"
  MEASURE_AXES_NOISE                                    ; get noise value in log
  _PRINT_AR T="BELT TEST: Resonance Tests starting ..."
  _PRINT_AR T="BELT TEST: Mesasure B belt"
  TEST_RESONANCES AXIS=1,1 OUTPUT=raw_data NAME=b
  _PRINT_AR T="BELT TEST: Mesasure A belt"
  TEST_RESONANCES AXIS=1,-1 OUTPUT=raw_data NAME=a
  _PRINT_AR T="BELT TEST: Resonance Tests done"
  _PRINT_AR T="BELT TEST: Generate graph in backround"
  RUN_SHELL_COMMAND CMD=plot_graph PARAMS=BELT

# Shell Comand is not supported by a default klipper installation 


[gcode_macro accelerometer_query_x]
gcode: ACCELEROMETER_QUERY CHIP=hotend

[gcode_macro accelerometer_query_y]
gcode: ACCELEROMETER_QUERY CHIP=bed

[gcode_macro RESONANCES_X]
gcode: TEST_RESONANCES AXIS=X

[gcode_macro RESONANCES_Y]
gcode: TEST_RESONANCES AXIS=Y

[gcode_macro RESONANCES_BOTH]
gcode: ACCELEROMETER_QUERY CHIP=hotend
       ACCELEROMETER_QUERY CHIP=bed
       lazy_home
       ACCELEROMETER_QUERY CHIP=hotend
       ACCELEROMETER_QUERY CHIP=bed
       TEST_RESONANCES AXIS=X
       TEST_RESONANCES AXIS=Y
       
[gcode_macro CALIBRATE_X]
gcode: SHAPER_CALIBRATE AXIS=X

[gcode_macro CALIBRATE_Y]
gcode: SHAPER_CALIBRATE AXIS=Y

[gcode_macro CALIBRATE_BOTH]
gcode:
      ACCELEROMETER_QUERY CHIP=hotend
      ACCELEROMETER_QUERY CHIP=bed
      lazy_home
      ACCELEROMETER_QUERY CHIP=hotend
      ACCELEROMETER_QUERY CHIP=bed
      SHAPER_CALIBRATE

[gcode_macro AXES_NOISE_AXIS]
gcode: MEASURE_AXES_NOISE 

[gcode_macro _CLIENT_VARIABLE]
#variable_use_custom_pos   : False ; use custom park coordinates for x,y [True/False]
#variable_custom_park_x    : 0.0   ; custom x position; value must be within your defined min and max of X
#variable_custom_park_y    : 0.0   ; custom y position; value must be within your defined min and max of Y
variable_custom_park_dz   : 20.0   ; custom dz value; the value in mm to lift the nozzle when move to park position
#variable_retract          : 1.0   ; the value to retract while PAUSE
#variable_cancel_retract   : 5.0   ; the value to retract while CANCEL_PRINT
#variable_speed_retract    : 35.0  ; retract speed in mm/s
#variable_unretract        : 1.0   ; the value to unretract while RESUME
#variable_speed_unretract  : 35.0  ; unretract speed in mm/s
#variable_speed_hop        : 15.0  ; z move speed in mm/s
#variable_speed_move       : 100.0 ; move speed in mm/s
#variable_park_at_cancel   : False ; allow to move the toolhead to park while execute CANCEL_PRINT [True/False]
#variable_park_at_cancel_x : None  ; different park position during CANCEL_PRINT [None/Position as Float]; park_at_cancel must be True
#variable_park_at_cancel_y : None  ; different park position during CANCEL_PRINT [None/Position as Float]; park_at_cancel must be True
## !!! Caution [firmware_retraction] must be defined in the printer.cfg if you set use_fw_retract: True !!!
#variable_use_fw_retract   : False ; use fw_retraction instead of the manual version [True/False]
#variable_idle_timeout     : 0     ; time in sec until idle_timeout kicks in. Value 0 means that no value will be set or restored
#gcode:
















